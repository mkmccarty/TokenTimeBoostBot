package bottools

import (
	"fmt"
	"go/format"
	"os"
	"reflect"
	"slices"
	"strings"

	ei "github.com/mkmccarty/TokenTimeBoostBot/src/ei"
)

// ---- Filters ----

var (
	// Fields we never include in any snapshot
	globalExcludes = []string{
		"state", "sizeCache", "unknownFields",
	}

	// Whitelist per struct (fields to keep)
	snapshotFieldWhitelist = map[string][]string{

		"ContractCoopStatusResponse": {
			"ResponseStatus",
			"ContractIdentifier",
			"TotalAmount",
			"CoopIdentifier",
			"Grade",
			"Contributors", // ContractCoopStatusResponse_ContributionInfo
			//"AutoGenerated",
			//"Public",
			//"CreatorId",
			"SecondsRemaining",
			"SecondsSinceAllGoalsAchieved",
			"AllGoalsAchieved",
			//"AllMembersReporting",
			"GracePeriodSecondsRemaining",
			"ClearedForExit",
			"clientTimestamp",
		},

		"ContractCoopStatusResponse_ContributionInfo": {
			//"Uuid",
			"UserId",
			"UserName",
			"ContractIdentifier",
			"ContributionAmount",
			"ContributionRate",
			//"SoulPower",
			"ProductionParams", // FarmProductionParams
			"FarmInfo",         // PlayerFarmInfo
			//"RecentlyActive",
			"Active",
			"CcMember",
			//"Leech",
			"Finalized",
			//"TimeCheatDetected",
			//"Platform",
			//"Autojoined",
			//"BoostTokens",
			//"BoostTokensSpent",
			"BuffHistory",
			"ChickenRunCooldown",
		},

		"FarmProductionParams": {
			"FarmPopulation",
			"FarmCapacity",
			"Elr",
			"Ihr",
			"Sr",
			"Delivered",
		},

		"PlayerFarmInfo": {
			//"ClientVersion",
			//"SoulEggs",
			//"EggsOfProphecy",
			"PermitLevel",
			"HyperloopStation",
			//"EggMedalLevel",
			"EpicResearch", // []Backup_ResearchItem
			//"EggType",
			//"CashOnHand",
			"Habs",          // []uint32
			"HabPopulation", // []uint64
			"HabCapacity",   // []uint64
			"Vehicles",      // []uint32
			"TrainLength",   // []uint32
			//"SilosOwned",
			"CommonResearch", // []Backup_ResearchItem
			"ActiveBoosts",   // []Backup_ActiveBoost
			//"BoostTokensOnHand",
			"EquippedArtifacts", // []CompleteArtifact
			//"ArtifactInventoryScore",
			//"FarmAppearance",
			"Timestamp",
		},

		"Backup_ResearchItem": {
			"Id",
			"Level",
		},

		"Backup_ActiveBoost": {
			"BoostId",
			"TimeRemaining",
			"ReferenceValue",
		},

		"CompleteArtifact": {
			"Spec",
			"Stones", // []ArtifactSpec
		},

		"ArtifactSpec": {
			"Name",
			"Level",
			"Rarity",
			"Egg",
		},

		"CoopBuffState": {
			"EggLayingRate",
			"Earnings",
			"ServerTimestamp",
		},
	}

	// Types that should be replaced with their snapshot versions
	snapshotReplacements = []string{
		"ContractCoopStatusResponse",
		"ContractCoopStatusResponse_ContributionInfo",
		"FarmProductionParams",
		"PlayerFarmInfo",
		"Backup_ResearchItem",
		"Backup_ActiveBoost",
		"CompleteArtifact",
		"ArtifactSpec",
		"CoopBuffState",
	}
)

// ---- Helpers ----

// isScalarLike reports types for which we drop pointers in snapshots.
func isScalarLike(t reflect.Type) bool {
	switch t.Kind() {
	// Drop pointers for basic scalar types
	case reflect.Bool, reflect.String,
		reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,
		reflect.Uintptr, reflect.Float32, reflect.Float64:
		return true
	}
	// Also drop pointers to named types that are scalar-like (e.g., enums).
	if t.Name() != "" && (t.Kind() >= reflect.Int && t.Kind() <= reflect.Uint64) {
		return true
	}
	return false
}

// renderSnapshotType renders the snapshot type: drop pointers for scalar-like/enums; keep for complex; recurse for containers.
func renderSnapshotType(t reflect.Type) string {
	switch t.Kind() {
	case reflect.Pointer:
		e := t.Elem()
		if isScalarLike(e) { // drop pointer for scalar-like (incl. enums)
			return renderSnapshotType(e)
		}
		return "*" + renderSnapshotType(e)
	case reflect.Slice:
		return "[]" + renderSnapshotType(t.Elem())
	case reflect.Array:
		return fmt.Sprintf("[%d]%s", t.Len(), renderSnapshotType(t.Elem()))
	case reflect.Map:
		return "map[" + renderSnapshotType(t.Key()) + "]" + renderSnapshotType(t.Elem())
	default:
		name := t.Name()
		if name == "" {
			return t.String() // builtins/unnamed
		}
		// Replace known protobuf types with snapshot versions
		for _, r := range snapshotReplacements {
			if name == r {
				return name + "_Snapshot"
			}
		}
		return name
	}
}

// Returns the original struct tag (protobuf/json/etc.) or empty if none.
func buildTags(f reflect.StructField) string {
	return string(f.Tag)
}

func shouldExclude(fieldName string) bool {
	return slices.Contains(globalExcludes, fieldName)
}

func isWhitelisted(structName, fieldName string) bool {
	allowed, exists := snapshotFieldWhitelist[structName]
	if !exists {
		// If no whitelist defined for struct, keep all fields except globals
		return true
	}
	return slices.Contains(allowed, fieldName)
}

// ---- Snapshot Generator ----

// generateSnapshotStruct dynamically creates a "flattened" snapshot struct
// from a protobuf-derived type. It removes pointer indirection for basic
// fields (float, int, string, bool) for performance and simplicity,
// but keeps slices and nested structs intact.
func generateSnapshotStruct(obj any) string {

	// Inspect the input via reflection
	rv := reflect.ValueOf(obj)
	if !rv.IsValid() {
		return "// GenerateSnapshotStruct: invalid obj"
	}

	// Pointer, handle nil and then dereference
	if rv.Kind() == reflect.Pointer {
		if rv.IsNil() {
			return "// GenerateSnapshotStruct: nil pointer"
		}
		// Work with the pointed-to value
		rv = rv.Elem()
	}
	// Or we can have a struct (or a pointer to a struct)
	if rv.Kind() != reflect.Struct {
		return "// GenerateSnapshotStruct: obj must be struct or *struct"
	}

	t := rv.Type()
	var b strings.Builder

	// Naming: <Original>_Snapshot
	fmt.Fprintf(&b, "type %s_Snapshot struct {\n", t.Name())

	for i := 0; i < t.NumField(); i++ {
		f := t.Field(i)

		// Skip internal protobuf fields
		if shouldExclude(f.Name) {
			continue
		}
		// Only include whitelisted fields
		if !isWhitelisted(t.Name(), f.Name) {
			continue
		}

		// Compute the snapshot field type from reflect.
		// Handles types slices, maps, arrays, pointers).
		ft := renderSnapshotType(f.Type)

		// Keep ALL original tags (protobuf + json + anything else) if present.
		tags := buildTags(f)

		// Write: "<FieldName> <FieldType> [`<tags>`]".
		// Only append backticked tags when they exist.
		fmt.Fprintf(&b, "\t%s %s", f.Name, ft)
		if tags != "" {
			fmt.Fprintf(&b, " `%s`", tags)
		}
		b.WriteByte('\n')

	}
	b.WriteString("}\n\n")
	return b.String()
}

// ---- Snapshot Writer ----

// GenerateSnapshots writes snapshot structs to outputPath for the listed protobuf types.
// Run this manually with:
//
//	go run ./src/bottools/cmd/run_snapshots.go
func GenerateSnapshots(outputPath, packageName string) error {
	var b strings.Builder

	// File header
	fmt.Fprintf(&b, `// Code generated by snapshotgen.go; DO NOT EDIT.
// This file contains lightweight snapshot structs derived from protobuf types.
// Run "go run ./src/bottools/cmd/run_snapshots.go" to regenerate.

package %s

`, packageName)

	// Structs to snapshot (source of truth)
	structs := []any{
		&ei.ContractCoopStatusResponse{},
		&ei.ContractCoopStatusResponse_ContributionInfo{},
		&ei.FarmProductionParams{},
		&ei.PlayerFarmInfo{},
		&ei.Backup_ResearchItem{},
		&ei.Backup_ActiveBoost{},
		&ei.CompleteArtifact{},
		&ei.ArtifactSpec{},
		&ei.CoopBuffState{},
	}

	// Generate each snapshot struct
	for _, s := range structs {
		b.WriteString(generateSnapshotStruct(s))
	}

	// Format the generated source (fallback to unformatted on error)
	src := []byte(b.String())
	if fmtd, err := format.Source(src); err == nil {
		src = fmtd
	}

	// Write the generated code to file
	if err := os.WriteFile(outputPath, src, 0644); err != nil {
		return fmt.Errorf("failed to write snapshot file: %w", err)
	}

	fmt.Printf("âœ… Snapshot file created: %s\n", outputPath)
	return nil
}
